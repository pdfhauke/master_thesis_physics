#now do a 1 dimensional fitting with the scipy.linalg.lstsq method

import numpy as np
from scipy.linalg import lstsq 
import matplotlib.pyplot as plt 
from pyarts import arts
from pyarts.plots import arts_lookup
import FluxSimulator as fsm

#define pressure grid 
#take pressure dependent cross section of ozone at 270 K 

# set frequency grid
min_wvn = 5

max_wvn = 3210
n_freq_lw = 200
wvn = np.linspace(min_wvn, max_wvn, n_freq_lw)
f_grid_lw = arts.convert.kaycm2freq(wvn)

# setup ARTS
flux_simulator_LUT = fsm.FluxSimulator("TESTLUT_SW")
flux_simulator_LUT.ws.f_grid = f_grid_lw
flux_simulator_LUT.set_species(
    ["CO2,CO2-CKDMT252","O3"]
)


# Wide LUT
flux_simulator_LUT.get_lookuptableWide(recalc=False)
LUT = flux_simulator_LUT.ws.abs_lookup.value

temperaturepoint = 11
specienumber = 0
frequencynumber = 145

x = np.log10(LUT.p_grid)
y = np.log10(LUT.xsec[temperaturepoint,specienumber,frequencynumber,:]) 


#first do linear fit 
def lin_fit(x, y):
    #tell which fit you want to do 
    #here a linear fit at x 
    M = np.ones((len(x),2))
    M[:,1] = x
    #M[:,2] = 
    #M[:,3] = x**3

    #do the linear fit
    poly, res, s, sing = lstsq(M,y)

    print(poly)
    return poly 

#function to evaluate the linear fit quality 
#res is always sum of squared residuals 
def lin_fit_qual(x, y):
    #tell which fit you want to do 
    #here a linear fit at x 
    M = np.ones((len(x),2))
    M[:,1] = x
    #M[:,2] = 
    #M[:,3] = x**3

    #do the linear fit
    poly, res, s, sing = lstsq(M,y)
    return res

#get linear fit quality 
polylinqual = lin_fit_qual(x,y)

# get the linear fit function 
def d(x):
    d = poly[0] +poly[1] * x
    return d 

poly = lin_fit(x,y)


#do a quadratic fit 
def quad_fit(x, y):
    #tell which fit you want to do 
    #here a linear fit at x 
    M = np.ones((len(x),3))
    M[:,1] = x
    M[:,2] = x**2
    #M[:,3] = x**3

    #do the quad fit
    poly, res, s, sing = lstsq(M,y)

    print(poly)
    return poly

#evaluate the quadratic fit function, returns res 
#res is always sum of squared residuals 
def quad_fit_quality(x, y):
    #tell which fit you want to do 
    #here a linear fit at x 
    M = np.ones((len(x),3))
    M[:,1] = x
    M[:,2] = x**2
    #M[:,3] = x**3

    #do the quad fit
    poly, res, s, sing = lstsq(M,y)

    print(poly)
    return res


#get quad fit function object
polyquad = quad_fit(x,y)

#object encapsulates the quality of the quadratic fit 
polyquadqual = quad_fit_quality(x,y)

# get the quadratic fit function 
def d2(x):
    d2 = polyquad[0] +polyquad[1] * x +polyquad[2]* x**2 
    return d2 
    
#do the cubic fitting 
def cube_fit(x, y):
    #tell which fit you want to do 
    #here a linear fit at x 
    M = np.ones((len(x),4))
    M[:,1] = x
    M[:,2] = x**2
    M[:,3] = x**3

    #do the cubic fit
    poly, res, s, sing = lstsq(M,y)

    print(poly)
    return poly 

#oject encapsulates the cubic fitting
polycube = cube_fit(x,y)

# get the cubic fit function 
def d3(x):
    d3 = polycube[0] +polycube[1] * x +polycube[2]* x**2 + polycube[3] * x**3
    return d3 

#evaluate the cubic fit quality 
#res is always sum of squared residuals 
def cube_fit_qual(x, y):
    #tell which fit you want to do 
    #here a linear fit at x 
    M = np.ones((len(x),4))
    M[:,1] = x
    M[:,2] = x**2
    M[:,3] = x**3

    #do the cubic fit
    poly, res, s, sing = lstsq(M,y)
    return res

#object encasulates the cubic fit quality 
polycubequal = cube_fit_qual(x,y)

#plot data and fits 
plt.plot(x,d(x), label = 'linear fit')
plt.plot(x,d2(x), label = 'quadratic fit')
plt.plot(x,d3(x), label = 'cubic fit')
plt.plot(x,y,'o', label ='data')
plt.xlabel("$log10(p/p_0$)")
plt.ylabel("log10(cross section [$m^2$]/cross_section$_0$)")
#plt.ylabel("cross section [$m^2$]")
plt.legend()
#plt.show()
#

#give important additional information about physics of this set up 
temperature = LUT.t_pert[temperaturepoint] + LUT.t_ref[temperaturepoint]
freqkays = wvn[frequencynumber]
species = 'CO2'
print("temperature: ",temperature)
print("frequency: ", freqkays)
print("species: ", species)
#print("temperature array", LUT.t_pert, LUT.t_ref)
#print("frequency array: ", wvn)
#output the fitting quality numbers res from the lstsq fitting of different orders 
#res is always sum of squared residuals 
print("linear fit quality: ", polylinqual)
print("quadratic fit quality: ", polyquadqual)
print("cubic fit quality: ", polycubequal)

#storage the plot with fit and simlated data 
#metadata =[temperature,freqkays]
#path = '/Users/hdamerow/master_thesis/pictures Master thesis playground /1 dim fits /einsdim_1to3_order_fit_295cm^(-1)_240K_O3.png'
#plt.savefig(path)


"""""
#now try out the 2 dimensional fit
#z_data = LUT.xsec[5,0,6,:]
#y = LUT.t_pert +LUT.t_ref
#x = np.log10(LUT.p_grid)

#x = np.array([0,2,4,6,8,10])
#y = np.array([1,10,20,40,60,80])

#z_data =np.array([[1,2,4,6,10,12],[2,5,4,7,7,9,],[1,1,1,3,3,3,],[2,6,4,8,10,15],[2,3,2,3,2,3],[10,20,40,60,80,2]])
#z_data = np.ndarray.flatten(z_data)

#real interesting data 

x = np.log10(LUT.p_grid)
y = LUT.t_pert + LUT.t_ref
z_data = np.ndarray.flatten(np.log10(LUT.xsec[:,specienumber,frequencynumber,:]))

def lin_fit_2dim(x,y,z):
    #tell which fit you want to do 
    #here a linear fit at x 

    #build your own M
    x = np.array([0,2,4,6,8,10])
    y = np.array([1,10,20,40,60,80])
    #import numpy as np 
    M = np.ones((36,3))
    i = 0   
    j = 0
    k = 0
    l = 0
    while i < 6:
        while l < 6:
            M[j,1] = x[i]
            j = j + 1
            l = l + 1
        i = i + 1
        l = 0

    j = 0
    l = 0
    i = 0
    while i < 6:
        while l < 6:
            M[j,2] = y[l]
            j = j + 1
            l = l + 1
        i = i + 1
        l = 0



    #M = np.ones((len(x),3))
    #M[:,1] = x
    #M[:,2] = y
    #M[:,3] = x**3

    #do the quad fit
    poly, res, s, sing = lstsq(M,z)

    print(poly)
    return poly   

result = lin_fit_2dim(x,y,z_data)

"""""

"""""
#build your own M
x = np.array([0,2,4,6,8,10])
y = np.array([1,10,20,40,60,80])
import numpy as np 
M = np.ones((36,3))
i = 0
j = 0
k = 0
l = 0
while i < 6:
    while l < 6:
        M[j,1] = x[i]
        j = j + 1
        l = l + 1
    i = i + 1
    l = 0

j = 0
l = 0
i = 0
while i < 6:
    while l < 6:
        M[j,2] = y[l]
        j = j + 1
        l = l + 1
    i = i + 1
    l = l + 1
"""""

#print("2dim coefficients", result)
#print ("M", M)
#print(z_data)
